"""
Sept 6 2011
Moved the shorter report html as the default display so the horsechoker must be viewed deliberately
Links still seem to work fine...

sept 4 2011
Finally got all the complications of getting mirbase precursors and mature forms split by species and
into the tool_data_table infrastructure.

Now to fix the outputs which are sprayed willy nilly all over the place...

================
August 2011
mirdeep2  wrapper for Galaxy


This wrapper just integrates all that hard work into the Galaxy framework
You must install mir2deep so it will run when this code calls it.
The tool expects to find the perl scripts in [galaxyroot]/tool-data/shared/miRDEEP2/
Galaxy datatypes_conf.xml must include an arf and fastqcollapsed datatypes as subclasses of tabular and fastq
The bam_to_arf.xml converter must be added to lib/galaxy/datatypes/converters and used to pre-convert bam files ready for mirdeep2


Please see the site http://www.mdc-berlin.de/en/research/research_teams/systems_biology_of_gene_regulatory_elements/projects/miRDeep/ 
for attribution of mir2deep itself.
This code is Copyright 2011 Ross lazarus
All rights reserved but licensed.
Licensed to you under the LGPL

mirdeep2 documentation shown below comes directly from http://www.mdc-berlin.de/en/research/research_teams/systems_biology_of_gene_regulatory_elements/projects/miRDeep/documentation.html
 
========================
name:
miRDeep2.pl
description:
Wrapper function for the miRDeep2.pl program package. The script runs all necessary scripts of the miRDeep2 package to perform a microRNA detection deep sequencing data anlysis.
input:
A fasta file with deep sequencing reads, a fasta file of the corresponding genome, a file of mapped reads to the genome in miRDeep2 arf format, an optional fasta file with known miRNAs of the analysing species and an option fasta file of known miRNAs of related species
output:
A spreadsheet and a html file with an overview of all detected miRNAs in the deep sequencing input data.
Examples:
The miRDeep2 module identifies known and novel miRNAs in deep sequencing data. The output of the mapper module can be directly plugged into the miRDeep2 module.
Example use 1:
The user wishes to identify miRNAs in mouse deep sequencing data, using default options. The miRBase_mmu_v14.fa file contains all miRBase mature mouse miRNAs, while the miRBase_rno_v14.fa file contains all the miRBase mature rat miRNAs. The '2>' will pipe all progress output to the report.log file.
miRDeep2.pl reads_collapsed.fa genome.fa reads_collapsed_vs_genome.arf miRBase_mmu_v14.fa miRBase_rno_v14.fa precursors_ref_this_species.fa -t Mouse 2>report.log
This command will generate a directory with pdfs showing the structures, read signatures and score breakdowns of novel and known miRNAs in the data, an html webpage that links to all results generated (result.html), a copy of the novel and known miRNAs contained in the webpage but in text format which allows easy parsing (result.csv), a copy of the performance survey contained in the webpage but in text format (survey.csv) and a copy of the miRNA read signatures contained in the pdfs but in text format (output.mrd). The ids in files miRBase_mmu_v14.fa and precursors_ref_this_species.fa need to be similar to each other. This is usually no problem if you downloaded both files from miRBase. Otherwise it can happen that the quantifier fails to produce results.
Example use 2:
As in example use 1, except that the user has already run quantifier.pl and wants to use this output to get information on the miRNAs not detected by miRDeep2 included in the html webpage. miRBase.mrd is a file generated by quantifier.pl:
miRDeep2.pl reads_collapsed.fa genome.fa reads_collapsed_vs_genome.arf miRBase_mmu_v14.fa miRBase_rno_v14.fa -t Mouse -q miRBase.mrd 2>report.log
This command will generate the same type of files as example use 1 above. The user wishes to identify miRNAs in deep sequencing data from an animal with no related species in miRBase:
miRDeep2.pl reads_collapsed.fa genome.fa reads_collapsed_vs_genome.arf none none none 2>report.log
This command will generate the same type of files as example use 1 above. Note that there it will in practice always improve miRDeep2 performance if miRNAs from some related species is input, even if it is not closely related.
"""
import optparse
import tempfile
import os
import sys
import subprocess
import time
import shutil
import re


MIRDEEPWEB="http://www.mdc-berlin.de/en/research/research_teams/systems_biology_of_gene_regulatory_elements/projects/miRDeep/"
def timenow():
    """return current time as a string
    """
    return time.strftime('%d/%m/%Y %H:%M:%S', time.localtime(time.time()))

def fix_subdir(adir,destdir):
    """ Galaxy wants everything in the same files_dir
    if os.path.exists(adir):
        for (d,dirs,files) in os.path.walk(adir):
            for f in files:
                sauce = os.path.join(d,f) 
                shutil.copy(sauce,destdir)   
    """
    if os.path.exists(adir):
        flist = os.listdir(adir) # get all files created
        for f in flist:
           if f.startswith('tmp'):
               continue
           apath = os.path.join(adir,f)
           if not os.path.isdir(apath):
               dest = os.path.join(destdir,f)
               if not os.path.isfile(dest):
                   shutil.move(apath,dest)
           else:
               fix_subdir(apath,destdir)
        try:
            shutil.rmtree(path=adir,ignore_errors=True)
        except:
            pass



def getFileString(fpath, outpath):
    """
    format a nice file size string
    """
    size = ''
    fp = os.path.join(outpath, fpath)
    s = fpath
    if os.path.isfile(fp):
        n = float(os.path.getsize(fp))
        if n > 2**20:
            size = ' (%1.1f MB)' % (n/2**20)
        elif n > 2**10:
            size = ' (%1.1f KB)' % (n/2**10)
        elif n > 0:
            size = ' (%d B)' % (int(n))
        s = '%s %s' % (fpath, size) 
    return s

class mirdeep2:
    """Class = wrapper
Fucking web docs are wrong - why don't people keep this shit up to date?
the current dreck perl script now says:

#####################################
#                                   # 
# miRDeep2                          # 
#                                   #
# last change: 07/07/2011           # 
#                                   #
#####################################

miRDeep2 started at 15:8:20


#Starting miRDeep2
#Starting miRDeep2
tool-data/shared/mirdeep2/miRDeep2.pl 

miRDeep2 started at 15:8:20




miRDeep2.pl reads genome mappings miRNAs_ref/none miRNAs_other/none precursors/none 2>report.log

This script enacts the miRDeep pipeline. The input files are:

reads         deep sequences in fasta format. The identifier should contain a prefix, a running
              number and a '_x' to indicate the number of reads that have this sequence.
              There should be no redundancy in the sequences.
genome        genome contigs in fasta format. The identifiers should be unique. 
mappings      file_reads mapped against file_genome. The mappings should be in arf format.
              For details on the format see the documentation.
miRNAs_ref    miRBase miRNA sequences in fasta format. These should be the known mature
              sequences for the species being analyzed.
miRNAs_other  miRBase miRNA sequences in fasta format. These should be the pooled known
              mature sequences for 1-5 species closely related to the species being
              analyzed.

precursors    miRBase miRNA precursor sequences in fasta format. These should be the known precursor
              sequences for the species being analyzed.

The output files produced are:

result.html   a html table giving an overview of novel and known miRNAs detected in the
              data. The table is hyperlinked to pdfs showing the signature and structure of
              each hairpin.
result.csv    spread-sheet format of results.html
survey.csv    spread-sheet of prediction accuracy for all score-cutoffs between -10 and 10.
output.mrd    text output of the reported hairpins.

Options:

-a int        minimum read stack height that triggers analysis. Using this option disables
              automatic estimation of the optimal value and all detected precursors are analyzed

-g int        maximum number of precursors to analyze when automatic excision gearing is used.
              default=50.000, if set to -1 all precursors will be analyzed

-b int        minimum score cut-off for predicted novel miRNAs to be displayed in the overview
              table. This score cut-off is by default 0.

-c            disable randfold analysis

-d            disable pdf generation

-t species    species being analyzed - this is used to link to the appropriate UCSC browser entry

-u            output list of UCSC browser species that are supported and exit

-v            remove directory with temporary files

-o            do not sort aligned reads in pdf files by sample, only used if multiple samples were used as input (see Readme for mor information)

-s file       File with known miRBase star sequences

-z tag        Additional tag appended to current time stamp

    """
    
    def __init__(self,myName=None,opts=None):
        """ setup cl for mirdeep2.pl
        """
        self.progname=myName
        self.opts = opts
        if not os.path.isdir(opts.output_dir):
            try:
                os.makedirs(opts.output_dir)
            except:
                print >> sys.stderr,'##Error: mir2deep wrapper unable to create or find output directory %s. Stopping' % (opts.output_dir)
                sys.exit(1)
        self.makeBed = opts.makeBed
        if self.makeBed:
            self.outbed = opts.outbed
        else:
            self.outbed = None
        cl = []
        a = cl.append  
        a(os.path.join(opts.exe_dir,'miRDeep2.pl')) # my hacked version dispenses with the expression_analyses_time$ subdirectory
        a('%s' % opts.input_collapsedfasta) # second param is input file. Blech
        a('%s' % opts.fasta) # second param is input file. Blech
        a('%s' % opts.input_arf) # second param is input file. Blech
        a('%s' % opts.mir)
        a('%s' % opts.relatedmir)
        a('%s' % opts.premir)
        if opts.starmir <> "none":
            a('-s %s' % opts.starmir)
        if opts.species <> None:
            a('-t %s' % opts.species)
        if opts.stackheight <> '0':
            a('-a %s' % opts.stackheight)
        if (opts.Rfam):
              assert os.path.isfile(opts.Rfam), "### error - passed --Rfam = %s but not found" % opts.Rfam
              a('-r %s' % opts.Rfam)
        a('-b %s' % opts.minscore)
        a('-g %s' % opts.maxprecursors)
        if not opts.randfold:
            a('-c') # supress
        self.cl = cl
     
    def clean_mirhtml(self,fname):
        """
        repair links 
        can also compress
        cleaner = Cleaner(page_structure=False,style=True)
        chtml = cleaner.clean_html(''.join(s))
        we have to deal with
             <tr><td nowrap="nowrap"><a href="file:///tmp/mirtest/pdfs_03_03_2012_t_14_05_19/hsa-mir-30a.pdf">hsa-mir-30a</a></td>
        </tr>      <tr><td><a href="pdfs_04_03_2012_t_13_36_17/chr1_277.pdf">chr1_277</a></td>

        """
        f = open(fname,'r')
        html = f.readlines()
        f.close()
        html = [x.replace('  ',' ') for x in html]
        html = [x for x in html if x.strip() > '']
        for i,row in enumerate(html):
            if row.lower().find('.pdf') <> -1: # need to adjust the pdf link for Galaxy html files
                rowstart,rowmeat = row.split('<a href',1) # first part to keep
                fn = rowmeat.split('</a></td>')[0]
                pdfname = fn.split('">')[0] # should be pdf name unless they change the html generator!
                pdfname = pdfname.split(os.path.sep)[-1] # get rid of bogus paths - we have moved everything up to extra_files_path
                pdfname = pdfname.strip()
                realpdf = os.path.join(self.opts.output_dir,pdfname)
                if not os.path.isfile(realpdf):
                     s = '%s not found' % realpdf
                     html[i] = '%s<a href="%s">%s %s</a></td>' % (rowstart,pdfname,pdfname,s)
                else:
                     html[i] = '%s<a href="%s">%s</a></td>' % (rowstart,pdfname,pdfname)
        ohtml = open(fname,'w')
        ohtml.write(''.join(html))
        ohtml.write('\n')
        ohtml.close()




    def getBed(self,rows=[]):
        """
        results...csv has:

        miRDeep2 score  novel miRNAs reported by miRDeep2       novel miRNAs, estimated false positives novel miRNAs, estimated true positi$
        10      57      5 +/- 3 52 +/- 3 (91 +/- 4%)    680     473     277 (59%)       31.8    1
        9       61      5 +/- 3 56 +/- 3 (92 +/- 4%)    680     473     277 (59%)       32.1    1
        8       63      5 +/- 3 58 +/- 3 (92 +/- 4%)    680     473     277 (59%)       31.8    1
        7       64      5 +/- 3 59 +/- 3 (92 +/- 4%)    680     473     277 (59%)       31.5    1
        6       66      6 +/- 3 60 +/- 3 (92 +/- 4%)    680     473     277 (59%)       31.2    1
        5       76      6 +/- 3 70 +/- 3 (92 +/- 4%)    680     473     347 (73%)       35.3    1
        4       86      7 +/- 3 79 +/- 3 (91 +/- 3%)    680     473     362 (77%)       31.2    1
        3       90      14 +/- 4        76 +/- 4 (84 +/- 4%)    680     473     365 (77%)       18      1
        2       109     20 +/- 4        89 +/- 4 (82 +/- 4%)    680     473     368 (78%)       14.1    1
        1       206     30 +/- 6        176 +/- 6 (85 +/- 3%)   680     473     382 (81%)       11.1    1
        0       254     103 +/- 11      151 +/- 11 (59 +/- 4%)  680     473     412 (87%)       4.2     1
        -1      319     207 +/- 15      112 +/- 15 (35 +/- 5%)  680     473     428 (90%)       2.5     1
        -2      384     413 +/- 20      0 +/- 2 (0 +/- 1%)      680     473     431 (91%)       1.5     1
        -3      573     585 +/- 23      5 +/- 9 (1 +/- 2%)      680     473     432 (91%)       1.4     1
        -4      1456    763 +/- 25      693 +/- 25 (48 +/- 2%)  680     473     435 (92%)       2.2     1
        -5      2054    1457 +/- 32     597 +/- 32 (29 +/- 2%)  680     473     436 (92%)       1.6     1
        -6      2285    3877 +/- 44     0 +/- 0 (0 +/- 0%)      680     473     436 (92%)       0.7     1
        -7      2582    5353 +/- 50     0 +/- 0 (0 +/- 0%)      680     473     436 (92%)       0.5     1
        -8      4089    6360 +/- 53     0 +/- 0 (0 +/- 0%)      680     473     436 (92%)       0.7     1
        -9      5602    7029 +/- 57     0 +/- 0 (0 +/- 0%)      680     473     436 (92%)       0.8     1
        -10     6513    7434 +/- 62     0 +/- 0 (0 +/- 0%)      680     473     436 (92%)       0.9     1



        novel miRNAs predicted by miRDeep2
        provisional id  miRDeep2 score  estimated probability that the miRNA candidate is a true positive   rfam alert  total read count    mature read count   loop read count star read count significant randfold p-value    miRBase miRNA   example miRBase miRNA with the same seed    UCSC browser    NCBI blastn consensus mature sequence   consensus star sequence consensus precursor sequence    precursor coordinate
        chr4_73445      57398.5 91 +/- 4%       -       112576  88309   0       24267   yes     -       rno-miR-148b-3p -       -       uca$
        chr8_95833      4597.2  91 +/- 4%       -       9008    8857    0       151     yes     -       rno-let-7d      -       -       uga$
        chrX_104990     2801.4  91 +/- 4%       -

        and later
        mature miRBase miRNAs detected by miRDeep2                                                              
        tag id  miRDeep2 score  estimated probability that the miRNA is a true positive rfam alert  total read count    mature read count   loop read count star read count significant randfold p-value    mature miRBase miRNA    example miRBase miRNA with the same seed    UCSC browser    NCBI blastn consensus mature sequence   consensus star sequence consensus precursor sequence    precursor coordinate
        chr3_62927  4314524.6   91 +/- 4%   0   8462746 8462620 0   126 yes rno-miR-10b rno-miR-10a-5p  0   0   uacccuguagaaccgaauuugu  acagauucgauucuaggggaau  uacccuguagaaccgaauuugugugguacccacauagucacagauucgauucuaggggaau   chr3:68113667..68113778:+

        """
        repout = None
        bedrows = []
        for i,row in enumerate(rows):
            rsplit = row.strip().split('\t')
            if len(rsplit) < 2:
                repout = None # out of segment
                continue
            if repout: # in a segment
                locus = rsplit[precpos].strip() # chr4:145680951..145681062:- is the last string
                bname = rsplit[precpos-7].strip()  
                if len(bname) < 2:
                    bname = locus # use coords
                #>>> re.compile(":|\.\.").split(foo)
                #['chr4', '145680951', '145681062', '-']
                bed = re.compile(":|\.\.").split(locus)
                strand = bed[-1]
                bed = bed[:-1]
                bed.append(bname)
                bed.append('0') # bed6 score
                bed.append(strand)
                bedrows.append(bed)
            elif rsplit[1].lower() == 'mirdeep2 score' and rsplit[0].lower() in ['tag id','provisional id'] : # start of a table
                if i > 0:
                    repout = row[i-1].replace(' ','_')
                    head = rsplit
                    precpos = head.index('precursor coordinate')
        decbr = [[x[0],int(x[1]),int(x[2]),x] for x in bedrows]
        decbr.sort()
        bedrows = ['\t'.join(x[-1]) for x in decbr]
        return bedrows
                



    def make_mirhtml(self,html):
        """
        Gak. 3.2MB of crap - must thin down...
        Gak. Need to fix mirdeep2 generated links like:
        <tr><td nowrap="nowrap"><a href="file:///data/galaxy/database/job_working_directory/7720/dataset_8401_files/pdfs_05_09_2011_t_13_34_54/hsa-mir-3655_MI0016055_Homo_sapien
        s_miR-3655_stem-loop.pdf">hsa-mir-3655_MI0016055_Homo_sapiens_miR-3655_stem-loop</a></td>
        <tr><td nowrap="nowrap"><a href="file:///data/galaxy/database/job_working_directory/7720/dataset_8401_files/pdfs_05_09_2011_t_13_34_54/hsa-mir-4709_MI0017342_Homo_sapien
        s_miR-4709_stem-loop.pdf">hsa-mir-4709_MI0017342_Homo_sapiens_miR-4709_stem-loop</a></td>
        """
        ourhead = []
        ourhead.append('<h2>miRDEEP2 Galaxy output generated by %s at %s</h2></br></hr>\n' % (self.progname,timenow()))
        ourhead.append('<table border="0" cellspacing="2"><tr><td>Galaxy CL</td><td>%s</td></tr>\n' % ' '.join(sys.argv))
        ourhead.append('<tr><td>Generated miRDeep2 CL</td><td>%s</td></tr></table>\n' % ' '.join(self.cl))
        ourhead.append('<tr><td>Documentation/Attribution</td><td><a href="%s">%s</a></td></tr></table>\n' % (MIRDEEPWEB,MIRDEEPWEB))
        ourhead.append('<h2>Outputs from mirdeep2.pl</h2></hr>\n')
        coda = [] # our coda is the head now
        flist = os.listdir(self.opts.output_dir)
        flist.sort()
        flist = [os.path.join(self.opts.output_dir,x) for x in flist] # ugh
        if len(flist) > 0:
            coda.append('<table>\n')
            for ofname in flist:
                fdir,fname = os.path.split(ofname)
                if fname.startswith('.nfs') or fname.endswith('.pdf') :
                     continue
                else:
                     coda.append('<tr><td><a href="%s">%s</a></td></tr>' % (fname,getFileString(fname,fdir)))
                if self.makeBed and fname.lower().startswith('result_') and fname.lower().endswith('.csv'): 
                    # make a bed file for bams2mx
                    outfname = self.outbed
                    outf = os.path.join(fdir,outfname)
                    rows = open(ofname,'r').readlines()
                    brows = self.getBed(rows) # make an interval file with all known and unannotated miRs
                    o = open(outf,'w')
                    o.write('\n'.join(brows))
                    o.write('\n')
                    o.close()
                    coda.append('<tr><td><a href="%s">%s</a></td></tr>' % (outfname,getFileString(outfname,fdir)))
            coda.append('</table>\n')
        else:
            coda.append('<h2>### Error - mirdeep2 returned no files - please confirm that parameters are sane</h2>')
        s = []
        for i,row in enumerate(html): # pass through - add our own header 
            row = row.replace('\n\n','\n')
            if len(row.strip()) == 0:
                continue # no room for blank rows
            if row.lower().find('<body>') <> -1:
                s.append(row)
                s += ourhead
                s += coda
            else:
                s.append(row)
        return s

    def run(self):
        """
        results are sprayed out all over the place:
        -rw-r--r-- 1 galaxy galaxy     265 2011-09-05 13:46 error.output.mrd_05_09_2011_t_13_34_54
        drwxr-xr-x 2 galaxy galaxy   12288 2011-09-05 13:38 pdfs_05_09_2011_t_13_34_54
        -rw-r--r-- 1 galaxy galaxy 3810541 2011-09-05 13:34 expression_05_09_2011_t_13_34_54.html
        -rw-r--r-- 1 galaxy galaxy  224197 2011-09-05 13:34 miRNAs_expressed_all_samples_05_09_2011_t_13_34_54.csv
        drwxr-xr-x 3 galaxy galaxy    4096 2011-09-05 13:32 expression_analyses
        drwxr-xr-x 3 galaxy galaxy    4096 2011-09-05 13:30 mirdeep_runs
        so we need to flatten and fix the html to suit our needs
        TODO deal with expression analyses?
        """
        p = os.getenv('PATH')
        edir = self.opts.exe_dir
        p = '%s:%s' % (edir,p)
        os.environ['PATH'] = p # fiddle env to include Galaxy local copy of mirdeep2 scripts
        tlog = os.path.join(self.opts.output_dir,"mirdeep2_mapper_runner.log")
        sto = open(tlog,'w')
        x = subprocess.Popen(' '.join(self.cl),shell=True,stdout=sto,stderr=sto,cwd=self.opts.output_dir,env=os.environ)
        retval = x.wait()
        sto.close()
        flist = os.listdir(self.opts.output_dir)
        exprdir = 'expression_analysis'
        mddir = 'mirdeep_runs'
        dirs = [exprdir,mddir]
        pdfdir = [x for x in flist if x.lower().startswith('pdfs_')]
        if len(pdfdir) > 0:
           dirs.append(pdfdir[0])
        for d in dirs:
             if d:
                 adir = os.path.join(self.opts.output_dir,d)
                 fix_subdir(adir,self.opts.output_dir)       
        allhtml = [x for x in flist if x.lower().endswith('.html')]
        if len(allhtml) > 0:
           for fname in allhtml:
               self.clean_mirhtml(os.path.join(self.opts.output_dir,fname)) # ugh. rewrite html with links all fixed
        reshtml = [x for x in allhtml if x.lower().startswith('result')]
        if len(reshtml) > 0:
           htmlfname = os.path.join(self.opts.output_dir,reshtml[0])     
           html = open(htmlfname,'r').readlines()
        else:
           errs = '#Error: strange - no result*.html file created by %s at %s' % (self.progname,timenow())
           html = ['<html>','<body>',errs,'</body></html>']
           retval = 1
           print >> sys.stderr, errs
        html = self.make_mirhtml(html)
        htmlf = file(self.opts.outhtml,'w')
        htmlf.write('\n'.join(html))
        htmlf.write('\n')
        htmlf.close()
        return retval
        

if __name__ == "__main__":
    """ 
    called as:
 <command interpreter="python">
    rgmiRDEEP2.py --input_arf "$input_arf" --input_collapsedfasta "$input_collapsedfasta" --output_dir "$html_file.files_path" --outhtml "$html_file"
    --stackheight "$stackheight" --exe_dir "$GALAXY_DATA_INDEX_DIR/shared/mirdeep2/" --species "$species" --minscore "$minscore" --maxprecursors "$maxprecursors"
#if $maturemirSource.mmSource != "none":
  #if $maturemirSource.mmSource == "history":
--mir "$maturemirSource.index"
  #else:
--mir "${ filter( lambda x: str( x[0] ) == str( $maturemirSource.index ), $__app__.tool_data_tables[ 'mature_miR_fasta' ].get_fields() )[0][-1] }"
  #end if
#end if
#if $precursormirSource.pmSource != "none":
 #if $precursormirSource.pmSource == "history":
--premir "$precursormirSource.index"
 #else:
--premir "${ filter( lambda x: str( x[0] ) == str( $precursormirSource.index ), $__app__.tool_data_tables[ 'hairpin_miR_fasta' ].get_fields() )[0][-1] }"
 #end if
#end if
#if $relatedmirSource.rmSource != "none":
 #if $relatedmirSource.rmSource == "history":
--relatedmir "$relatedmirSource.index"
 #else:
--relatedmir "${ filter( lambda x: str( x[0] ) == str( $maturemirSource.index ), $__app__.tool_data_tables[ 'mature_miR_fasta' ].get_fields() )[0][-1] }"
 #end if
#end if
#if $starmir.value != "None":
--starmir "$starmir"
#end if
#if $genomeSource.refGenomeSource=="history":
--fasta "$genomeSource.index"
#else
--fasta "${ filter( lambda x: str( x[0] ) == str( $genomeSource.index ), $__app__.tool_data_tables[ 'all_fasta' ].get_fields() )[0][-1] }"
#end if
$randfold
  </command>
    """
    op = optparse.OptionParser()
    a = op.add_option
    a('--input_arf',default=None)
    a('--input_collapsedfasta',default="none")
    a('--mir',default="none")
    a('--premir',default="none")
    a('--relatedmir',default="none") 
    a('--starmir',default="none") 
    a('--stackheight',default='0')
    a('--fasta',default=None)
    a('--Rfam',default="/data/genomes/miR18/Rfam.fa")
    a('--species',default='Human')
    a('--minscore',default='0')
    a('--maxprecursors',default='50')
    a('--outhtml',default=None)
    a('--output_dir',default=None)
    a('--jtitle',default='miRDeep2')
    a('-e','--exe_dir',default=None)
    a('-c','--randfold',action="store_true",default=False)
    a('-b','--makeBed',action="store_true",default=False)
    a('--outbed',default=None)
    opts, args = op.parse_args() 
    assert os.path.isfile(opts.input_arf),'## mirdeep2 runner unable to open supplied input file %s' % opts.input_arf
    assert os.path.isfile(opts.input_collapsedfasta),'## mirdeep2 runner unable to open supplied input collapsed fasta file %s' % opts.input_collapsedfasta
    assert os.path.isfile(opts.input_arf),'## mirdeep2 runner unable to open supplied input arf file %s' % opts.input_arf
    assert os.path.isfile(opts.fasta),'## mirdeep2 runner unable to open supplied reference fasta input file %s' % opts.fasta
    myName=os.path.split(sys.argv[0])[-1]
    m = mirdeep2(myName, opts=opts)
    retcode = m.run()
    if retcode:
        sys.exit(retcode) # indicate failure to job runner
    
    
