<tool id="rgedgeRfactorial" name="edgeRFactorial" version="0.18">
  <description>digital DGE Factorial design</description>
  <command interpreter="python">
     rgToolFactory.py --script_path "$runme" --interpreter "Rscript" --tool_name "edgeR" 
    --output_dir "$html_file.files_path" --output_html "$html_file" --make_HTML "yes"
  </command>
  <inputs>
    <param name="input1"  type="data" format="tabular" label="Select an input matrix - rows are contigs, columns are counts for each sample"
       help="Use the DGE matrix preparation tool to create these matrices from BAM files and a BED file of contigs"/>
    <param name="title" type="text" value="Factorial DGE" size="80" label="Title for job outputs" help="Supply a meaningful name here to remind you what the outputs contain">
      <sanitizer invalid_char="">
        <valid initial="string.letters,string.digits"><add value="_" /> </valid>
      </sanitizer>
    </param>
    <param name="treatment1_name" type="text" value="Treatment1" size="50" label="Treatment1 Name"/>
    <param name="Treat1_cols" label="Select samples for treatment one" type="data_column" data_ref="input1" numerical="True" 
         multiple="true" use_header_names="true" size="120" display="checkboxes">
        <validator type="no_options" message="Please select at least one column."/>
    </param>
    <param name="control1_name" type="text" value="Control1" size="50" label="Control1 Name"/>
    <param name="Control1_cols" label="Select samples for control one." type="data_column" data_ref="input1" numerical="True" 
         multiple="true" use_header_names="true" size="120" display="checkboxes" optional="true">
    </param>
    <param name="treatment2_name" type="text" value="Treatment2" size="50" label="Treatment2 Name"/>
    <param name="Treat2_cols" label="Select samples for treatment two" type="data_column" data_ref="input1" numerical="True" 
         multiple="true" use_header_names="true" size="120" display="checkboxes">
        <validator type="no_options" message="Please select at least one column."/>
    </param>
    <param name="control2_name" type="text" value="Control2" size="50" label="Control2 Name"/>
    <param name="Control2_cols" label="Select samples for control 2" type="data_column" data_ref="input1" numerical="True" 
         multiple="true" use_header_names="true" size="120" display="checkboxes" optional="true">
    </param>
    <param name="fQ" type="float" value="0.3" size="5" label="Non-differential contig count quantile threshold - zero to analyze all non-zero read count contigs"
     help="May be a good or a bad idea depending on the biology and the question. EG 0.3 = sparsest 30% of contigs with at least one read are removed before analysis"/>
    <param name="useNDfilt" type="boolean" truevalue="T" checked='false' falsevalue="" size="1" label="Non differential filter - remove contigs below a threshold (1 per million) for half or more samples"
     help="May be a good or a bad idea depending on the biology and the question. This was the old default. Quantile based is available as an alternative"/>
    <param name="priorn" type="integer" value="4" size="3" label="prior.df for tagwise dispersion - lower value = more emphasis on each tag's variance - note this used to be prior.n"
     help="Zero = auto-estimate. 1 to force high variance tags out. Use a small value to 'smooth' small samples. See edgeR docs and note below"/>
    <param name="fdrthresh" type="float" value="0.05" size="5" label="P value threshold for FDR filtering for family wise error rate control"
     help="Conventional default value of 0.05 recommended"/>
    <param name="fdrtype" type="select" label="FDR (Type II error) control method" 
         help="Use fdr or bh typically to control for the number of tests in a reliable way">
            <option value="fdr" selected="true">fdr</option>
            <option value="BH">Benjamini Hochberg</option>
            <option value="BY">Benjamini Yukateli</option>
            <option value="bonferroni">Bonferroni</option>
            <option value="hochberg">Hochberg</option>
            <option value="holm">Holm</option>
            <option value="hommel">Hommel</option>
            <option value="none">no control for multiple tests</option>
    </param>
  </inputs>
  <outputs>
    <data format="tabular" name="outtab1" label="${treatment1_name}-${control1_name}_topTable.xls"/>
    <data format="tabular" name="outtab2" label="${treatment2_name}-${control2_name}_topTable.xls"/>
    <data format="tabular" name="outtab3" label="${treatment1_name}-${control1_name}-${treatment2_name}-${control2_name}_topTable.xls"/>
    <data format="html" name="html_file" label="${input1.name}_${title}.html"/>
  </outputs>
<configfiles>
<configfile name="runme">
# edgeR.Rscript
# new nov 2012 for 2x2 factorial designs 
# updated nov 2011 for R 2.14.0 and edgeR 2.4.0 by ross
# Performs DGE on a count table containing n replicates of two conditions
#

reallybig = log10(.Machine\$double.xmax)
reallysmall = log10(.Machine\$double.xmin)
require('stringr')
require('gplots')
hmap2 = function(cmat,nsamp=100,outpdfname='heatmap2.pdf', TName='Treatment',group=NA,myTitle='title goes here')
{
    samples = colnames(cmat)
    gu = unique(group)
    if (length(gu) == 2) {
        col.map = function(g) {if (g==gu[1]) "#FF0000" else "#0000FF"}
        pcols = unlist(lapply(group,col.map))        
        } else {
        colours = rainbow(length(gu),start=0,end=4/6)
        pcols = colours[match(group,gu)]        }
    print(paste('pcols',pcols))
    gn = rownames(cmat)
    dm = cmat[(! is.na(gn)),] 
    nprobes = nrow(dm)
    if (nprobes &gt; nsamp) {
      dm =dm[1:nsamp,]
    }
    newcolnames = substr(colnames(dm),1,20)
    colnames(dm) = newcolnames
    pdf(outpdfname)
    heatmap.2(dm,main=myTitle,ColSideColors=pcols,col=topo.colors(100),dendrogram="col",key=T,density.info='none',
         Rowv=F,scale='row',trace='none',margins=c(8,8),cexRow=0.4,cexCol=0.5)
    dev.off()
}

hmap = function(cmat,nmeans=4,outpdfname="heatMap.pdf",nsamp=250,TName='Treatment',group=NA,myTitle="Title goes here")
{
    gu = unique(group)
    colours = rainbow(length(gu),start=0.3,end=0.6)
    pcols = colours[match(group,gu)]
    nrows = nrow(cmat)
    mtitle = paste(myTitle,'Heatmap: n contigs =',nrows)
    if (nrows &gt; nsamp)  {
               cmat = cmat[c(1:nsamp),]
               mtitle = paste('Heatmap: Top ',nsamp,' DE contigs (of ',nrows,')',sep='')
          }
    newcolnames = substr(colnames(cmat),1,20)
    colnames(cmat) = newcolnames
    pdf(outpdfname)
    heatmap(cmat,scale='row',main=mtitle,cexRow=0.3,cexCol=0.4,Rowv=NA,ColSideColors=pcols)
    dev.off()
}

qqPlot = function(descr='Title',pvector, ...)
{
    o = -log10(sort(pvector,decreasing=F))
    e = -log10( 1:length(o)/length(o) )
    o[o==-Inf] = reallysmall
    o[o==Inf] = reallybig
    pdfname = paste(gsub(" ","", descr , fixed=TRUE),'pval_qq.pdf',sep='_')
    maint = paste(descr,'QQ Plot')
    pdf(pdfname)
    plot(e,o,pch=19,cex=1, main=maint, ...,
        xlab=expression(Expected~~-log[10](italic(p))),
        ylab=expression(Observed~~-log[10](italic(p))),
        xlim=c(0,max(e)), ylim=c(0,max(o)))
    lines(e,e,col="red")
    grid(col = "lightgray", lty = "dotted")
    dev.off()
}

smearPlot = function(DGEList,deTags, outSmear, outMain)
        {
        pdf(outSmear)
        plotSmear(DGEList,de.tags=deTags,main=outMain)
        grid(col="blue")
        dev.off()
        }
        
boxPlot = function(rawrs,cleanrs,maint,myTitle)
{    
        newcolnames = substr(colnames(rawrs),1,15)
        colnames(rawrs) = newcolnames
        newcolnames = substr(colnames(cleanrs),1,15)
        colnames(cleanrs) = newcolnames
        pdfname = paste(gsub(" ","", myTitle , fixed=TRUE),"sampleBoxplot.pdf",sep='_')
        defpar = par(no.readonly=T)
        pdf(pdfname,height=6,width=8)
        par(mfrow=c(1,2)) 
        boxplot(rawrs,main=paste('Before:',maint),col="maroon",las=3,cex.axis=0.4)
        grid(col="blue")
        lrs = log(cleanrs,10) 
        boxplot(cleanrs,main=paste('After:',maint),col="maroon",las=3,cex.axis=0.4)
        grid(col="blue")
        dev.off()
        par(defpar)
}

cumPlot = function(rawrs,cleanrs,maint,myTitle)
{   
        pdfname = paste(gsub(" ","", myTitle , fixed=TRUE),"RowsumCum.pdf",sep='_')
        defpar = par(no.readonly=T)
        pdf(pdfname)
        par(mfrow=c(2,1))
        lrs = log(rawrs,10) 
        lim = max(lrs)
        hist(lrs,breaks=100,main=paste('Before:',maint),xlab="Reads (log)",
             ylab="Count",col="maroon",sub=myTitle, xlim=c(0,lim),las=1)
        grid(col="blue")
        lrs = log(cleanrs,10) 
        hist(lrs,breaks=100,main=paste('After:',maint),xlab="Reads (log)",
             ylab="Count",col="maroon",sub=myTitle,xlim=c(0,lim),las=1)
        grid(col="blue")
        dev.off()
        par(defpar)
}

cumPlot1 = function(rawrs,cleanrs,maint,myTitle)
{   
        pdfname = paste(gsub(" ","", myTitle , fixed=TRUE),"RowsumCum.pdf",sep='_')
        pdf(pdfname)
        par(mfrow=c(2,1))
        lastx = max(rawrs)
        rawe = knots(ecdf(rawrs))
        cleane = knots(ecdf(cleanrs))
        cy = 1:length(cleane)/length(cleane)
        ry = 1:length(rawe)/length(rawe)
        plot(rawe,ry,type='l',main=paste('Before',maint),xlab="Log Contig Total Reads",
             ylab="Cumulative proportion",col="maroon",log='x',xlim=c(1,lastx),sub=myTitle)
        grid(col="blue")
        plot(cleane,cy,type='l',main=paste('After',maint),xlab="Log Contig Total Reads",
             ylab="Cumulative proportion",col="maroon",log='x',xlim=c(1,lastx),sub=myTitle)
        grid(col="blue")
        dev.off()
}



edgeIt = function (Count_Matrix,group,outtab1,outtab2,outtab3,fdrtype='fdr',priorn=5,fdrthresh=0.05,outputdir='.',
                   myTitle='edgeR',libSize=c(),useQuantile=T,filterquantile=0.2,org='hg19') 
{
    
    if (length(unique(group))!=4) {
    print.noquote("Number of conditions identified in experiment does not equal 4 - full 2x2 factorial not possible")
    q()
    }
    require(edgeR)
    require(limma)
    mt = paste(unlist(strsplit(myTitle,' ')),collapse="")
    expfact = factor(group,levels=unique(group)) 
    sampleTypes = levels(expfact)
    mycontrast = NA
    colnamesDesign = list()
    allN = nrow(Count_Matrix)
    nscut = round(ncol(Count_Matrix)/2)
    colTotmillionreads = colSums(Count_Matrix)/1e6
    rawrs = rowSums(Count_Matrix)
    nonzerod = Count_Matrix[(rawrs &gt; 0),] 
    nzN = nrow(nonzerod)
    nzrs = rowSums(nonzerod)
    zN = allN - nzN
    print.noquote('Quantiles for non-zero row counts:')
    print.noquote(quantile(nzrs,probs=seq(0,1,0.1)))
    if (useQuantile == "T")
    {
      gt1rpin3 = rowSums(Count_Matrix/expandAsMatrix(colTotmillionreads,dim(Count_Matrix)) &gt;= 1) &gt;= nscut
      lo = colSums(Count_Matrix[!gt1rpin3,])
      workCM = Count_Matrix[gt1rpin3,]
      cleanrs = rowSums(workCM)
      cleanN = length(cleanrs)
      meth = paste( "After removing",length(lo),"contigs with fewer than",nscut,"sample read counts &gt;= 1 per million, there are",sep="")
      print.noquote(paste("Read",allN,"contigs. Removed",zN,"contigs with no reads.",meth,cleanN,"contigs"))
      maint = paste('Filter &gt;= 1/million reads in &gt;=',nscut,'samples')
    }  else {        
      useme = (nzrs &gt; quantile(nzrs,filterquantile))
      workCM = nonzerod[useme,]
      lo = colSums(nonzerod[!useme,])
      cleanrs = rowSums(workCM)
      cleanN = length(cleanrs)
      meth = paste("After filtering at count quantile =",filterquantile,"there are",sep="")
      print.noquote(paste('Read',allN,"contigs. Removed",zN,"with no reads.",meth,cleanN,"contigs"))
      maint = paste('Filter below',filterquantile,'quantile')
    }
    cumPlot(rawrs=rawrs,cleanrs=cleanrs,maint=maint,myTitle=myTitle)
    print.noquote(paste("Total low count contigs per sample = ",paste(lo,collapse=',')))
    rsums = rowSums(workCM)
    allttn = c()
    colnamesDesign = list()
    l = sampleTypes
    p1=paste(l[1],'-',l[2],sep='')
    p2=paste(l[3],'-',l[4],sep='')
    p3=paste('(',l[3],'-',l[4],') - (',l[1],'-',l[2],')',sep='')
    colnamesDesign = list(comp1=p1,comp2=p2,diff=p3)
    mydesign = model.matrix(~0+expfact)
    colnames(mydesign) = sampleTypes   
    mycontrast = makeContrasts(contrasts=colnamesDesign,levels=mydesign)
    print.noquote('Design matrix=')
    print(mydesign,quote=F)
    print.noquote('Contrast matrix=')
    print(mycontrast,quote=F)
    print.noquote('Samples=')
    print(colnames(workCM),quote=F)
    DGEList = DGEList(counts=workCM, group = group)
    print.noquote(paste("prior.df =",priorn))
    DGEList = calcNormFactors(DGEList)
    DGEList = estimateGLMCommonDisp(DGEList,mydesign)
    comdisp = DGEList\$common.dispersion
    DGEList = estimateGLMTrendedDisp(DGEList,mydesign)
    DGEList = estimateGLMTagwiseDisp(DGEList,mydesign)
    pdf(paste(mt,"BCV_vs_abundance.pdf",sep='_'))
    plotBCV(DGEList, cex=0.3, main="Biological CV vs abundance")
    dev.off()    
    estpriorn = getPriorN(DGEList)
    print(paste("Common Dispersion =",comdisp,"CV = ",sqrt(comdisp),"getPriorN = ",estpriorn),quote=F)
    normData = (1e+06 * DGEList\$counts/expandAsMatrix(DGEList\$samples\$lib.size, dim(DGEList)))
    colnames(normData) = paste( colnames(normData),'N',sep="_")
    boxPlot(rawrs=log(nonzerod),cleanrs=log(normData),maint='TMM Normalisation (log scale)',myTitle=myTitle)
    ug = unique(group)
    sample_colors =  match(DGEList\$samples\$group,ug) 
    pdf(paste(outputdir,paste(mt,"MDSplot.pdf",sep='_'),sep='/'))
    plotMDS.DGEList(DGEList,main=paste("MDS Plot for",myTitle),cex=0.5,col=sample_colors,pch=sample_colors)
    legend(x="topleft", legend = sampleTypes,col=sample_colors, pch=19)
    grid(col="blue")
    dev.off()
    cn = colnames(Count_Matrix)
    print('Using design matrix:')
    print(mydesign)
    DGLM = glmFit(DGEList, mydesign)
    goodness = gof(DGLM, pcutoff=fdrthresh)
    if (sum(goodness\$outlier) &gt; 0) {
        print.noquote('GLM outliers:')
        rownames(DGLM)[goodness\$outlier]
        z = limma::zscoreGamma(goodness\$gof.statistic, shape=goodness\$df/2, scale=2)
        pdf(paste(mt,"GoodnessofFit.pdf",sep='_'))
        qq = qqnorm(z, panel.first=grid(), main="tagwise dispersion")
        abline(0,1,lwd=3)
        points(qq\$x[goodness\$outlier],qq\$y[goodness\$outlier], pch=16, col="dodgerblue")
        dev.off()
    } else { print('No GLM fit outlier genes found\n')}
    outtabs = c(outtab1,outtab2,outtab3)
    for (coeff in c(1:3))
        {
        DE = glmLRT(DGLM,contrast=mycontrast[,coeff])
        cont = paste(unlist(strsplit(colnames(mycontrast)[coeff],' ')),collapse="")
        output = cbind(Name=as.character(rownames(DGEList\$counts)),
        DE\$table,adj.p.value=p.adjust(DE\$table\$PValue, method=fdrtype),
        Dispersion=DGEList\$tagwise.dispersion,totreads=rsums,normData,
        DGEList\$counts)
        soutput = output[order(output\$PVal),] 
        nreads = soutput\$totreads 
        write.table(soutput,outtabs[coeff], quote=FALSE, sep="\t",row.names=F)
        print.noquote(paste("Top tags for",cont))
        genecards="&lt;a href='http://www.genecards.org/index.php?path=/Search/keyword/"
        ucsc = paste("&lt;a href='http://genome.ucsc.edu/cgi-bin/hgTracks?db=",org,sep='')
        tt = topTags(DE,n=nrow(DE))
        rn = rownames(tt\$table)
        reg = "^chr([0-9]+):([0-9]+)-([0-9]+)"
        testreg = str_match(rn,reg)
        isucsc = F
        if (!is.na(testreg[1,])) {isucsc = T}
        if (isucsc == T)
        {
          urls = paste(ucsc,'&amp;position=chr',testreg[,2],':',testreg[,3],"-",testreg[,4],"'&gt;",rn,'&lt;/a&gt;',sep='')
        } else {
          urls = paste(genecards,rn,"'&gt;",rn,'&lt;/a&gt;',sep="")
        }
        tt\$table = cbind(tt\$table,ntotreads=nreads,geneCardslink=urls) 
        print.noquote(tt[1:50,])
        deTags = rownames(output[output\$adj.p.value &lt; fdrthresh,])
        nsig = length(deTags)
        print(paste(nsig,'tags significant at adj p=',fdrthresh),quote=F)
        outSmear = paste(outputdir,paste(mt,cont,"Smearplot.pdf",sep='_'),sep='/')
        outMain = paste(cont,' (FDR@',fdrthresh,' N = ',nsig,')',sep='')
        smearPlot(DGEList=DE,deTags=deTags, outSmear=outSmear, outMain = outMain)
        qqPlot(descr=paste(myTitle,cont),pvector=DE\$table\$PValue)
        }
}

rossDecide = function (object, adjust.method="BH", p.value=0.05,verbose=T) 
{
    if (!is(object, "DGEExact") &amp; !is(object, "DGELRT")) 
        stop("Need DGEExact or DGELRT object")
    DE = decideTestsDGE(object, adjust.method = adjust.method, p.value = p.value)
    sumDE = summary(DE)
    rownames(sumDE)[1] = "DOWN"
    rownames(sumDE)[3] = "UP"
    sumDE = sumDE[c(3, 1), ]
    if (verbose) {
        cat("\n")
        cat("------------------------------------------------------", 
            "\n")
        cat(" Method for Selecting DEGs:", DEmethod, "\n")
        cat(" Multiple Testing  method: ", MTestmethod, "- pval", 
            PVcut, "\n")
        cat("\n")
        print.noquote(sumDE)
        cat("------------------------------------------------------", 
            "\n")
    }
    return(DE)
}

options(width=512)
Out_Dir = "$html_file.files_path"
Input =  "$input1"
Treatment1Name = "$treatment1_name"
Treatment1Cols = "$Treat1_cols"
Control1Name = "$control1_name"
Control1Cols= "$Control1_cols"
Treatment2Name = "$treatment2_name"
Treatment2Cols = "$Treat2_cols"
Control2Name = "$control2_name"
Control2Cols= "$Control2_cols"
org = "$input1.dbkey"
outtab1 = "$outtab1"
outtab2 = "$outtab2"
outtab3 = "$outtab3"
fdrtype = "$fdrtype"
priorn = $priorn
fdrthresh = $fdrthresh
useNDfilt = "$useNDfilt"
fQ = $fQ 
myTitle = "$title"
TCols1           = as.numeric(strsplit(Treatment1Cols,",")[[1]])-1
CCols1           = as.numeric(strsplit(Control1Cols,",")[[1]])-1 
TCols2           = as.numeric(strsplit(Treatment2Cols,",")[[1]])-1
CCols2           = as.numeric(strsplit(Control2Cols,",")[[1]])-1 
print.noquote(paste('# got TCols1=',paste(TCols1,collapse=',')))
print.noquote(paste('# got CCols1=',paste(CCols1,collapse=',')))
print.noquote(paste('# got TCols2=',paste(TCols2,collapse=',')))
print.noquote(paste('# got CCols2=',paste(CCols2,collapse=',')))
Count_Matrix = read.table(Input,header=T,row.names=1,sep='\t')                           
Count_Matrix = Count_Matrix[,c(TCols1,CCols1,TCols2,CCols2)]
group = c(rep(Treatment1Name,length(TCols1)),rep(Control1Name,length(CCols1)),
         rep(Treatment2Name,length(TCols2)),rep(Control2Name,length(CCols2)))
rn = rownames(Count_Matrix)
nsamp = length(colnames(Count_Matrix))
testcols = c(TCols1,CCols1,TCols2,CCols2)
if (length(unique(testcols)) &lt; length(testcols)) {
   print.noquote('Error - one or more samples reused - cannot allow this in a factorial design!')
   print.noquote(paste('Duplicated columns = ',paste(rn[testcols[duplicated(testcols)]],collapse=',')))
   q()
}
if (file.exists(Out_Dir) == F) dir.create(Out_Dir)
print.noquote(paste('Got nsamp = ',nsamp,'org=',org))
islib = rn %in% c('librarySize','NotInBedRegions')
LibSizes = Count_Matrix[subset(rn,islib),][1] 
Count_Matrix = Count_Matrix[subset(rn,! islib),]
print(paste('Got groups =',paste(group,collapse=' ')))
if (priorn &lt;= 0) {priorn = ceiling(20/(length(group)-1))} 
cn = colnames(Count_Matrix)
results = edgeIt(Count_Matrix,group=group,outtab1=outtab1,outtab2=outtab2,outtab3=outtab3,fdrtype,priorn,fdrthresh,
                 Out_Dir,myTitle,libSize=c(),useQuantile=useNDfilt,filterquantile=fQ,org=org) 
options(width=80)
sessionInfo()

</configfile>
</configfiles>
<tests>
<test>
<param name='input1' value='DGEtest.xls' ftype='tabular' />
 <param name='treatment_name' value='case' />
 <param name='title' value='DGEtest' />
 <param name='fdrtype' value='fdr' />
 <param name='priorn' value="5" />
 <param name='fdrthresh' value="0.05" />
 <param name='control_name' value='control' />
 <param name='Treat_cols' value='c3,c6,c9' />
 <param name='Control_cols' value='c2,c5,c8' />
 <output name='outtab' file='DGEtest1out.xls' ftype='tabular' compare='diff' />
 <output name='html_file' file='DGEtest1out.html' ftype='html' compare='diff' lines_diff='20' />
</test>
</tests>
<help>
**Executive Summary**
This is a Galaxy wrapper exposing the Bioconductor edgeR_ package.
There is a companion pairwise comparison tool but this is the Factorial model tool.
It will help you to analyse the interaction and main effects in a 2x2 factorial design.

**If things go wrong**
edgeR software is thoroughly documented at edgeR_Manual_ and the authors 
provide excellent support on the Bioconductor users' mailing list for their code, but
if this tool fails to run properly in Galaxy, please make sure you 
fill in the form and send the administrators a Galaxy bug report. 
If you have questions about the edgeR code this tool wraps, please 
try the Bioconductor users' list. 

**What data is it for?**
Like the pairwise version, it takes a count matrix with columns containing reads per contig (NOT transformed!) for 
multiple replicates in comparison groups. The counts can be any kind of counts. It was designed for
short read sequence data - RNA-seq, miR-seq,...ChIP-seq. 

**Slightly Longer Version**
Performs digital gene expression factorial analysis for a 2x2 design.
Factorial designs are old but good if you want to get at the individual effects and interaction between two factors.
EG: a treatment applied to 2 different cell types, or two treatments applied in all 4 possible combinations (-a-b,-a,+b,+a-b,+a+b).
Data with replicates in the four groups is supplied as a count matrix.
The two primary comparisons are defined by selecting two sets of samples for comparison
best thought of as control and treatment (whatever that means) for each of the main comparisons. 

The interaction is defined as the difference between those two comparisons and is reported as a topTable as are the 
primary comparisons.

All comparisons are reported as separate tabular spreadsheets ordered by p value and a comprehensive summary is 
provided in the html output.

This code essentially embelishes the code described by Gordon Smythe in the limma documentation for a factorial 
analysis.

**Input**

A matrix consisting of non-negative integers. The matrix must have a unique header row identifiying the samples, as well as a unique set of row names 
as the first column.

**Output**

Tabular files which contain the statistical results and the raw and transformed counts and some colourful
and helpful plots

**Note on edgeR versions**

The edgeR authors made a small cosmetic change in the name of one important variable (from p.value to PValue) 
breaking this and all other code that assumed the old name for this variable, 
between edgeR2.4.4 and 2.4.6 (the version for R 2.14 as at the time of writing). 
This means that all code using edgeR is sensitive to the version. I think this was a very unwise thing 
to do because it wasted hours of my time to track down and will similarly cost other edgeR users dearly
when their old scripts break. This tool currently now works with 2.4.6.

**Note on prior.N - now replaced with prior.df**

http://seqanswers.com/forums/showthread.php?t=5591 says:

*prior.n*

The value for prior.n determines the amount of smoothing of tagwise dispersions towards the common dispersion. 
You can think of it as like a "weight" for the common value. (It is actually the weight for the common likelihood 
in the weighted likelihood equation). The larger the value for prior.n, the more smoothing, i.e. the closer your 
tagwise dispersion estimates will be to the common dispersion. If you use a prior.n of 1, then that gives the 
common likelihood the weight of one observation.

In answer to your question, it is a good thing to squeeze the tagwise dispersions towards a common value, 
or else you will be using very unreliable estimates of the dispersion. I would not recommend using the value that 
you obtained from estimateSmoothing()---this is far too small and would result in virtually no moderation 
(squeezing) of the tagwise dispersions. How many samples do you have in your experiment? 
What is the experimental design? If you have few samples (less than 6) then I would suggest a prior.n of at least 10. 
If you have more samples, then the tagwise dispersion estimates will be more reliable, 
so you could consider using a smaller prior.n, although I would hesitate to use a prior.n less than 5. 

 .. _edgeR: http://www.bioconductor.org/packages/release/bioc/html/edgeR.html
 .. _edgeR_Manual: http://www.bioconductor.org/packages/release/bioc/vignettes/edgeR/inst/doc/edgeRUsersGuide.pdf

</help>

</tool>


